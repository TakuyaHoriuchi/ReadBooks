# 1. 一巡目
|question|回答|正誤|不明選択肢|
|:--:|:--|:--:|:--
|1|125|○|
|2|134|○|
|3|2|○|?
|4|13|○|24
|5|？|✕|Fieldも付け継がれる？
|6|14|✕|import static
|7|2|✕|345
|8|135|✕|????
|9|2|○|

- パッケージ宣言より前に何らかのコードを記述するとエラー
- <font color="Purple" size=4>パッケージ宣言しない場合、デフォルトパッケージに所属を表現。その時は無名パッケージからしかアクセスできない。
- <font color="Purple" size=4>javalang packageはデフォルトインポート
- 同じメソッド名をStatic importした時はオーバーロードされるため、インポート漏れは無い
- <font color="Purple" size=4>Staticインポートされたものと同じField,methodをクラス内に定義したときインポートは無視される。
- エントリーポイント➜処理の開始地点：メインメソッド(引数名以外は変えられない)
- main methodの条件：public, インスタンスなしでも実行出来る(staticであること), void, main, string配列型を１つ受けるコト
- 可変長引数のStringも受け取れる。
- JavaコマンドはJVMを起動するためのコマンド。

# 2. 一巡目
|question|回答|正誤|不明選択肢|
|:--:|:--|:--:|:--
|1|3 or 4|○|compile or doing error
|2|4||
|3|!5679||
|4|4||
|5|13||
|6|1||
|7|3||
|8|2|○|
|9|5|○|
|10|4|○|
|11|1||
|12|12|○|

- <font color="Purple" size=4>整数リテラルの問題：１６進数0x,2:0b~,8:0~
- Javaでは１０進数以外でも表記出来る
- みやすさのために数値の間に_を入れることも可能
- char型は文字コードを導入できるし文字数値を代入できる。
- thisの変数もインスタンスの中に存在する数値
- <font color="Purple" size=4>不要なインスタンスをJVMが勝手に削除することをガベージコレクションという。Null代入すると対象から外れる


# 3. 一巡目 JAVA判定ロジック
|question|回答|正誤|不明選択肢|
|:--:|:--|:--:|:--
|1|4||
|2|3||
|3|2||
|4|5||
|5|3|○|
|6|1|○|
|7|4||
|8|1 or 2||
|9|2||
|10|3||
|11|4|nullPo|
|12|4|○|
|13|4||
|14|1|○|
|15|3||
|16|3|○|
|17|3||
|18|without 1,2||
|19|1, 4||
|20|4||
|21|2|○|
|22|4|○|

- <font color="Purple" size=4>ーは演算子以外に反転子としても使用可能
- byteは127まで
- long -> intへのCastは無理
- ？float値として扱えないほど小さいdouble値のため
- <font color="Purple" size=4>++a, a++ は前置きだと変数＋１が即時適用。後置なら次の項では＋１が適用される。
- <とかで比較出来るのは数値のみBooleanは比較出来ない。
- newでインスタンス化されると変数は別の参照基なる。
- 同じクラス内なら別インスタンスでも値比較が可能。？？
- 文字列リテラルは、インスタンス生成用にメモリに別途保持していて、同じ文字列なら同じ参照元になる。コンプスタントプール
- <font color="Purple" size=4>同一性をチェックする➜==, 同値性をCheck➜equals
- if文は分岐処理を{}無しで記載可能。ただし次の一行しか中身の処理は実行されない。
- switch文の戻り値はint型以下の整数型とそのラッパークラス。文字列と文字。列挙型。Long型は返せない
- case地は、定数である必要あり（Finalやリテラル）
- case文はBreakがないと以降の全てのCase文が実行される。Default文も。
- ３項演算子➜ A？B：C 


# 4. 一巡目
|question|回答|正誤|不明選択肢|
|:--:|:--|:--:|:--
|1|4||
|2|5||
|3|3||
|4|1,2,6|○|
|5|3||
|6|3|○|
|7|134||
|8|2||
|9|1||
|10|3||
|11|?||

- プリミティブ型とオブジェクティブ型の配列がある。値生成か参照かのち外。
- 配列のSyspriは名前＠ハッシュ値で返却される。
- 配列変数を宣言する時の[]は変数名の前後に自由につけられる。
- new int[]{}のとき{2,3}とかにした時に[2]などとしてはいけない
- int[] b = {} という初期化演算子{}は宣言時にしか使えない。
- 配列.clone()で複製した配列を==で比較するとFalseになる➜別インスタンス。コンスタントプールにより値格納先は同一。　<font color="Red">【クローンしたもののインスタンスが別か、値は一緒か確認】</font>
- arraycopyの使い方は複雑

# 5. 一巡目
|question|回答|正誤|不明選択肢|
|:--:|:--|:--:|:--
|1 |1|○|
|2 |3|○|
|3 |4 or 5|△|
|4 |1||
|5 |5|○|参照不明
|6 |2|○|
|7 |4|○|
|8 |1|○|
|9 |3|○|
|10|134|○|
|11|1|○|
|12|1||
|13|4||12
|14|3 or 1|△|
|15|1 ?||
|16|6|○|
|17|1||
- <font color="Purple" size=4>continue = skip
- do while {}なしだと一行だけ。
- for文の初期化エリアは同じ型しか定義出来ない。
- 初期化文と更新文はカンマ区切りで複数記述可能
- <font color="Purple" size=4>for文で使っている変数はprops扱い、stateのように値置換はthisとかを使わないと無理。
- breakは直近ループからの脱出
- ラベルをつける事でbreak continueの処理先を自由に指定可能になる。



# 6. 一巡目
|question|回答|正誤|不明選択肢|
|:--:|:--|:--:|:--
|1 |5|○|?3
|2 |1|○|
|3 |23|○|
|4 |3|○|
|5 |5||? ...
|6 |3|○|? void時のreturn
|7 |1||
|<font color="Red" size=6>8 |46||static わかりません
|9 |24|○|
|10|1|○|
|11|5|○|
|12|2||
|13|2||
|14|5or3||
|15|1||
|16|2|○|?14➜NotMethod
|17|1||
|18|1||?field扱い方
|<font color="Red" size=6>むずい19|3|○|
|20|4or2|○|
|21|1|○|props扱い？プリミティブ型値渡し
|22|2|○|オブジェクト型参照渡し
- float 32 double 64 bit
- <font color="Purple" size=4>[...]:可変長変数（自動的に配列にCast）
- 引数に「int... num」というように値を設定出来る。
- 可変長変数は最後に定義（何番目がどの変数か判断出来ないため）
- 到達不可能なコードはコンパイルエラー(return後の処理)
- メソッドやFieldはstatic領域とヒープ領域に配置。
- <font color="Purple" size=4>Static FieldはClass名.Field名　OR　Variable名.Field名でアクセス可能。 
- <font color="Purple" size=4>StaticMethodからNonStaticなMethodやFieldにアクセス出来ない。
- Static-○➜Static
- Static-✕➜NonStatic
- NonStatic-○➜Static(FieldOnly) ,,,,NonStatic-○➜NonStatic
- (dou,int)や(int,dou)に対してint,intするとどちらのメソッドか分からない。曖昧な呼び出しによるコンパイルエラー
- コンストラクタにアクセス修飾子の制限はない。
- ConstをPrivにし、StaticなgetInstance()methodを定義すればインスタンスを一つに制御出来る。
- publicメソッドからthisで呼び出すことも可能。
- 戻り値Voidを設定するとConstにならずMethodになる。
- 初期化ブロックはコンストラクタの前に呼ばれる。
- デフォルトコンストラクタは何か１つでもConstを定義すると生成されない。
- 別のコンストラクタを呼ぶ時ははじめにthis()などと書かないとだめ。
- Fieldにアクセス修飾子がないと、別パッケージから値を引っ張ってこれない。

# 7. 一巡目
|question|回答|正誤|不明選択肢|
|:--:|:--|:--:|:--
|1 |4|○|
|2 |1||?3
|3 |45||
|4 |145||
|5 |1|○|
|6 |1|○|
|7 |4||
|8 |5||?Fieldはいつ作られるのか分からない
|9 |1||
|10|1|○|
|11|3||
|12|6|○|?123
|13|1||
|14|14|○|
|15|1||
|16|2||
|17|1|○|
- <font color="Purple" size=4>
- 継承元のFieldと被った時はどちらのFieldも存在している。
- Fieldが実装された場合、Fieldで参照した場合宣言した型の方を使用
- 継承関係にあるクラス同士だけでなく、IFとの実現の関係でも成立する。
- Interface型で設定した時、定義したものでしか設定出来ない。
- UpCast:サブクラスをSuperクラスに変換すること。
- Superクラスで扱っていたものを元の型に戻すことをDownCastという。
- Superクラスのメソッドを実行する(Fieldを取得する機能)時は、
- SuperクラスのFieldを参照しにいく。
- コンストラクタはSuperから実行される。super();が頭に追記されるイメージ。

# 8. 一巡目
|question|回答|正誤|不明選択肢|
|:--:|:--|:--:|:--
|1 |2||ArrayIndexOutOfBounds
|2 |2||args nullpo
|3 |1||exception階層
|4 |2||nullの型
|5 |1||returnとfinally
|6 |||
|7 |||
|8 |||
|9 |||
|10|||
|11|||
|12|||
|13|||
|14|||
|15|||
|16|||
|17|||
|18|||
|19|||
|20|||
|21|||
|22|||
- <font color="Purple" size=4>



# 9. 一巡目
|question|回答|正誤|不明選択肢|
|:--:|:--|:--:|:--
|1 |||
|2 |||
|3 |||
|4 |||
|5 |||
|6 |||
|7 |||
|8 |||
|9 |||
|10|||
|11|||
|12|||
|13|||
|14|||
|15|||
|16|||
|17|||
|18|||
|19|||
|20|||
|21|||
|22|||
|23|||
|24|||
|25|||
|26|||
|27|||
|28|||
|29|||
|30|||
|31|||
|32|||
|33|||
|34|||
|35|||
|36|||
|37|||
|38|||
- <font color="Purple" size=4>