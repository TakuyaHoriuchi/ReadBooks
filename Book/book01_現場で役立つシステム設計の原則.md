
システム設計の原則
TODO　メソッド小さくする理由まとめ
TODO　型を利用した実装。　２賞P58,59
TOSE　インスタンス変数
TOSE　シナリオクラス
TOSE　一意性制約
TOSTU　非同期メッセージング通信
１
疎結合で編集のし易いコードを心がける。➜メソッド・クラスは小さく

わかりやすい変数名・間違い易い変数名は型を作ってしまう。

2
if elseを減らすことで疎結合化を推進出来る。

//定義クラス
class FeeFactory {
    static Map<String, Fee> types;
    static {
        types.put("adult", new AdultFee());
        types.put("child", new ChildFee());
    }
    static Fee feeByName(String name) {
        return types.get(name);
    }
}
//実行コード
FeeFactory.feeByName("adult")

//enum…列挙型;
enum FeeTyoe {
    adult,
    child,
    senior
}
("adult").equals(FeeType.adult)
FeeType.values();
EnumSet.of(adult, child);

3
DTOなどにわけたとしても手続き型の設計（データクラスと機能クラスを分けて管理している。）だと、
・変更の対象箇所を特定するために、プログラムの広い葉にを調べる必要がある。
・１つの変更要求に対して、プログラムのあちこちの修正がひつよう
・変更の副作用が起きていないことを確認するための大量のテスト。
・同じ業務ロジックがちこちに重複して書かれる。
・どこに業務ロジックが書いてある化見通しが悪くなる。
のデメリット！

DAOクラスの生成時は、テータのみを格納するクラスを作るのはうまく機能しない。➜ロジックも一体化しよう。
かといって全てをまとめた汎用的メソッドを作ってもうまくいかない。

ドメインオブジェクト・・・業務データとロジックをひとまとめに置いているオブジェクト
を作ると便利。
ドメインモデルは画面やDBの都合から独立させる。
➜WF開発的モデル。

４
データ・モデルとドメインモデルの違い。
年齢を扱うとき、データ・モデルは生年月日しか扱わない。
ドメインモデルは年齢を扱うために年齢クラス内のインスタンス変数として仕方なく生年月日を持っておく。

オブジェクト指向で業務ロジックを整理していても外部のイベントに応答するAPPそうのクラスには
IF分を使った業務的なはんd何ロジックが増えがち。➜少しのIF文が発展し、複雑なコードを生む。
➜ドメインオブジェクトの役割を予め設定しておく
・ドメインモデルは業務ロジックをオブジェクト指向で整理する技法
・データではなくロジックを整理
・業務の関心事をヒトモノコトで整理する。
・コトは整理しやすい。整理の軸にする。
・起きても良いことだめなことの判断と対応が業務ルール。
・具体例を元に作成するとやりやすい。
・業務の理解を勧めながら書くことになる。

５
画面：PR層ー進行役：AP層ー記録通知のしくみ：DS層
　　　　　　　USE-業務ロジック：ドメインモデル

AP層の役割。
Request受取・ドメインオブジェクトを利用・Response返す・DS層の操作。
サービスクラスと呼ぶ。

SpringFreamworkで自動生成をサポート
@service・・・サービスクラスの自動せいせい。DS層のクラスのオブジェクトを自動的に組み込む。
@Controller（HTTPリクとのMap・ドメインOBJへのMap・AP層のクラスOBJを自動的に組み込む）
@Repository（DAO自動生成）も組み込む。

サービスクラスのメソッドは重複しがち
理由：ドメインOBJにロジックを整理しきれていない。
　　　PR層の関心事に振り回される。
　　　DBの都合に引きずられる。

基本的には小さく実装。
約束事として、
・Nullの受け渡しをしない
・状態に依存する場合、使う側が事前に確認する。
・以上は例外ハンドリング。

シナリオクラスを上手く活用。

６
DB設計でのリスク
可読性・整合性
・どこに度のデータが入っているか推測しにくい。
・データが入っていないカラム多い
・データ重複
・１つのカラムが複数用途で使用される。
・TBL間の関係が曖昧

避けたいカラム設定
NULL入っている・他のカラムに依存して意図が変化する
・分解が必要・意味難解なコード値・名前に一貫性が無い。

カラム多いTBLの悪い傾向
・NULL多い、似たカラムが多い

良いTBL設計をするために
・名前省略しない
・適切なデータ型
・制約をしっかり
中でもコトに着目し、
・記録のタイミングをTBLごとに一致させる。
・記録TBLにはUPDATE使わない。DELETE・INSERTでやる。元データ・取り消しデータ・新データって感じで・・・
・カラムを追加したい時はTBLの整合性を保つためにTBL自体を追加したほうが良い
・状態は記録から導出。

ドメインOBJには
・クラス・メソッドの命名方法、FWが要求するメソッドの追加、MapにAnnotationを適用
を要求すること強いてくるものがあるがそれはNG。
ロジックの記載に徹し、DBの都合などは引き継がないようにする。
フレームワークへの適用などが役割範囲外。


７画面とドメインの連動
画面表示ロジックと業務ロジックは分ける必要あり。
➜重複の恐れ
例：
if(amount > 100,000 && orderDate.before(LocalDate.now()) )
    classAppend('important')
１０万以上なら強調するCSSクラス追加。➜これは業務ロジック

最近はタスクベースで画面を分けるのが主流（例：Amazon）➜スマホ対応するためにシンプルな操作感を求められる。

なるべくドメインOBJと画面を連動させたいが出来ない理由がある。
・画面には様々な関心ごとが複合していて、粒度がDomainOBJと合わないことがある。
・表示ロジックはドメインロジックに持ち込むのはふてきせつ。
➜対策は表示ロジックを作成　OR　DTO作成。　DTO作るとどこでもロジックが記載出来るようになり✕
ドメインOBJには<p>とか段落の先頭は一時下げなどの物理的な制御。論理なら持ってても可
画面表示のIFRAMESはドメインOBJに組み込めないか思案。

例：
①
class items {
    List<Item> items;
    String found() {
        if(items.count() == 0) return "Not Found." ;
        return String.format("Found %s results.",
         items.count());
    }
}
// 条件分岐をItemsクラスに限定出来る。

②
String readStatus() {
    if( isUnread() ) return "unread";
    return "";
}
//Use in html
<p class="${mail.readStatus}">

画面表示用のクラスならば出力不要なFieldは定義しないなどの工夫をしても良い。

画面デザイン原則４つ
関連した情報はなるべく近く・インデント揃える
・重いの違いは文字サイズや色などで表現・同じ意味は同様の表示で

機能追加時は以下の整合性は必須
SalesPointの表記・説明・ガイド追加・ドメインOBJ追加
リリースノート・ガイド・ドメインOBJが整合しているソフトウェアは健全。

８AP間連携
AP間連携方式
・A.ファイル転送・B.DB共有・C.WebAPI・D.非同期メッセージングによる連携(文字だけ共有)
A
○：連携が楽
✕：処理の時間差、ファイル形式の変更はむずい
B
○：Aよりデータ転送は早い
✕：セキュリティ維持が困難、TBLとプログラムが密結合➜変更に弱い
C
○：AP間のやり取りが自由・システム連携の汎用性が高い
✕：設計判断が難しい、API仕様変更が難しい、HTTP通信の同期型の処理方式が運用・性能面の制約につながる恐れあり。
D
○：非同期でAP間を疎結合にでき、独立性を高める。さらにデータ連携しないため超高速。
✕：同期型とは違う設計・運用のノウハウ必須、安定したメッセージング基盤を構築運用しなければいけない。➜設計が鬼複雑


Web APIの基本仕様
・TCP/IP（インターネット）で接続
・HTTP通信
・データ形式はJSON,XML　➜複雑ならば階層化等が出来るXMLおすすめ（P264）
・UTF-8
約束事
・URI指定
・HTTPメソッド指定
・（処理結果）HTTPステータスコードは要送信
・Responseデータ形式指定

データ登録メソッドはPOST以外にPUTもある。
TOSE　PUTの使用Situation

GETの?以降はクエリパラメータ
でもなるべくURIパスで指定すべき、意図が理解しにくいため
データ登録・削除は疎結合よりのPOSTでやるべき
５００エラーはサーバ側

WebAPIの粒度は
大きい：機能の多様性✕、シンプル○
小さい：機能の多様性○、シンプル✕

SwaggerUI：API仕様書、テスト環境自動生成。
作るもの：EndPointのURL仕様、JSON出力形式、Parameters仕様
　　　　　、Curlコマンドサンプル、テストのフォーム（入力・実行・応答内容表示）
API作成時は、登録参照は分け、リソースの単位を分ける。
バージョン管理も可能だが、あまり意味は無い。

Web　APIの考慮事項
・マスタ項目のコードと名称
複数用途で別途APIを用意する。
・合計の計算
計算方法が一意ならばAPI側・ユーザに依存するなら生データ。（例：年齢の計算ロジックなど…）
・日付データの形式
日付と時刻は別データ補完おすすめ➜日付データはタイムゾーンに関係のないデータとして扱えるから。

基本、APIの設計は３種類に分けてグルーピングし、使用状況に際してAPIをグループ移行したりする。
・基本API、拡張API、個別対応API

マイクロサービス➜１つのAPだったものを小分けにするシステム構築方式
疎結合にはできるが、変更が大変（手間・大幅な仕様変更が難しい・メンテコスト増）のためやたらめったらやってはいけない
➜機能の分離が確実に確認出来るものを分離。

９おすすめ開発手法
必要なドキュメント
利用者向け・画面や帳票（要件定義書も兼ねられる）・データモデルと設計のコメント

システム概要説明・プレ版・更新履歴・ガイド導入部分？・パッケージデザイン
は共有しておきたい。

非機能要件のテストコード管理できるもの
（・テストコードのログをDocument化してしまう方法）
・監視ツールの設定・実行スクリプト
（・性能テストのコード）
・脆弱性診断　OK
・認証・認可のテスト
（・疑似障害を発生させ自動復旧することを確認するテスト）

１０
オブジェクト指向とは？

オブジェクト・クラス・インスタンス・カプセル化
・ポリモーフィズム・継承・Interface
いずれも意味不明
コード塊を部品化して再利用できる？
拡張修正が用意？
バグLow？

オブジェクト指向が強いのはソフトウェアの変更のとき。
勉強しよう！

リファクタリングのコツ
重複コード・・・変更が大変
長いメソッド・・・可動性大幅Lower
対策：
重複コードをメソッドに抽出、他のクラスにもあったら一つだけの実装にして参照させるよう変更する。

巨大クラス・・・インスタンス変数多い・巨大なデータクラスを受け取る・Many引数受取
インスタンス変数を使っているメソッドごとにグルーピング、場合によっては別クラス

過激なCoding規則で実装することでOBJ指向の勉強になると思う。



（感想）
適切な部品の分け方を学ぶきっかけとなった。
可読性が高く、柔軟性のあるシステムを設計するために、
クラスやメソッドを疎結合を意識し、
プレゼンテーション層・アプリケーション層・業務ロジック・DS層などのように
適切に役割を分割したら、適切な場所で書くことを徹底する必要性を学んだ。
・テストコードのログをDocument化してしまう方法などの思いつかなった発想が勉強出来た。

（どのような業務があるから〜〜が必要、そのために〜〜するという形で掘り下げていき構想を決めていく。
）
HTTP通信の知見補完になった。


