DB研修

中村・たまこし・つじ
今回の学ぶゴール
SGAの構成要素　PDA　PGA
データベースインスタンスとは
DB構成ファイルには何が含まれるか
RAC
リスナーの役割
SQLの実行結果共有
UPDATE処理
排他制御



クリーンアーキテクチャー　メリット
Entities・Use Cases Contrlers ui
フレームワークからの独立
テスト可能
UIからの独立
DBから独立
外部機能からの独立

ORM object Relation map
- hibernate
- activeRecords

DBを意識する必要はORMを使っててもある。
DBを意識しない実装によりテストで問題が発生、大幅な手戻り→開発コスト
PF：DBに適さないSQLの発行でPFが劣化
管理コスト：誤ったSQLの書き方・オブジェクトの設計をして、障害が他春。

設計・環境構築/開発・試験・運用

・クライアント
OracleDB
　・インスタンス　メモリ領域＋プロセス郡
    PGA
    SGA
　・DB
    データファイル
    REDIリグファイル


プロセス
→　サーバ・バックグラウンド

ps -ef | grep -i oraclecdb01 | grep -v grep

sqlplus / as sysdba

SGAバッファ。キャッシュ。ヒット率

SGA：共有プール→SQL分実行計画
バッファ・キャッシュ→アクセスしたデータ・ブロックのコピー
REDOログ・バッファ→変更履歴

データファイル→どこにTableを補完しているかを格納
REDOログバッファは上書きシて四王される領域
上書きしたくない場合mギイアーカイブREDOログ・ファイル。

マルチて何度アーキテクチャ
redoなどはバイナリファイル

初期パラメータファイル→制御ファイ

OracleだとActive-Active構成になる。
他ではHA構成やレプリケーションの場合で

スケールアップにも活用されている。

ユーザと直接やり取りするサーバプロセスがある。

ユーザとサーバのプロセスの橋渡し→　リスナー

RACではDBサービスを指定する

TCP接続タイムアウトまでわからないが、VIPの利用によってTCP接続タイムアウトを知ることが出来る

オプティマイザがアクセスパスとか結合とかを考えて、それを元にデータを撮ってくる

実行計画をどう扱うか
が作られてデータをとってくる。

構文チェック、セマンティックチェック（存在をチェック）、共有プールから存在するかのチェック
解析済SQLとは？？　どこに格納している？？
ソフトパース：
ハードパース：CPU不可が高まる

リテラル値はバインド変数にする
SQLは同じものになることで共有化される。
リテラル値を使うSQLは基本的に設計する。
大文字小文字も区別されハードパースが起こる。

膨大な数のソートが発生する場合、PGAの領域があふれる→

REDOログには何が入っている。

完全性を担保するためにUNDOセグメントへ逆トランザクション情報を保存する。

SQLの実行の流れは
まずは実行を行う時に
SQLチェクを行う。
静的解析などを終わったら、すでに解析済かどうかを確認する。
も解析済であれば実行計画から実行をおこヌア。



REDOログファイルとして永続化シているので永続性を実現シている。

更新中データはUNDOセグメントから取得している。これで一貫性を実現

【文レベル読み取り一貫性】
途中で更新されてても、COMMIT前の情報をとってくれる、→OracleDB
他ではCOMMITされたものを取ったりすることもある、
消されてていない場合はORA-1555エラーだったりする。


デットロックした場合はアプリケーション側で対策する必要あり。

CacheFusion
各ノード感でキャッシュ一貫性を維持する仕組み




## 第二回
良いSQLを知る・可読性・パフォ性に優れたSQLの書き方を身につける。

初っ端　わからなかった所
SQLのレスポンスタイムの定義
Indexの使われ方
バインド変数が使われない事の影響
JOINのルール
テーブルの結合順序

見やくパフすォーマンスを活用出来るもの

SQLコーディングガイド
・予約後：大文字、ユーザ定義後；小文字、戦闘に管理用のコメントをつける。[システム識別名]_[昨日識別名]

select /* SYS001_FUNC000 */ employee_id,
last_name,first_name from employees where
job_id = 'IT_PROG' order by last_name,
first_name;

↓
SELECT /* SYS001_FUNC000 */
    employee_id, last_name, first_name
FROM
    employees 
WHERE
    job_id = 'IT_PROG' 
ORDER BY
    last_name, first_name;

CIなどでSQLをチェックするツールも存在し、SQLDeveloperなどを使用してフォーマッターをかけてくれたりする。

SQLレスポンスタイム　＝　CPU時間　＋　待機時間
本来ソートが必要ないのにソート処理を指定う。
索引検索で良いのに全表走査となっていて、長いディスクI/O待ち時間がある。

定型的なチューニングや、非定型的なチューニングによってPFを上げたい。

クエリ実行計画とは、ユーザが発行した問い合わせに基づきDBMSが内部的に生成する情報であり、
これによりDBMSの行うデータ処理がプログラム的に表される。



OracleDBのデフォルト索引ではB * ツリーを採用
少ないデータを取る時は少ないデータブロックで済むため、時は索引検索が有効
⚠ employee_idがインデックスが使われる形　→　employee_idを計算式にすると✕！

INDEXショットガン

⚠ なるべく関数を使わないINDEXを使うよう心がける。
⚠ 連結演算子を使用しないかたちでSQLが掛けるよう検討
⚠ デート型がDATEフォーマットパラメータによって日付が変わる
　　意図した型変換ができなくなる恐れがあるから
　　デートフォーマットによってSQLが通らなくなるのでちゃんとDATEFORMATを使いましょう。
　　DataFormatの設定通りに打たないと通らないが、DATEFORMATとして指定して打つことで、通るようになるので指定して打とう。
⚠ IS NULLはINDEXが適用されない。
⚠ TRUE FALSE UNKNOWNがあってUNKNOWNは結果が返ってこない。
　　後方一致のLIKE条件を使用するとINDEXが適用されない。
　　ただ、前方一致のLIKE条件ならINDEXが適用される。
⚠ 索引の仕組みが先頭の文字を基準にINDEXを作成しているから。
後方一致で検索させないように論理設計しないと行けない。

⚠ 複合索引の先頭列を検索条件にしていない。
リーフブロックを全部さわっていくので、データブロックのアクセス数が増加してしまう。

v$sysstat システム変数。
ハードぱーすの回数を数えると、大変な事になっている。
→ちゃんとBind変数を利用しましょう！

SQLをSGAの共有プールに追加するが、IN OUTが多いと断片が増える。
ORA-4031　「」
このままインスタンスの停止をせざるをえなくなってしまう。
CPU高付加以外にもCriticalがエラーを引き起こす。
必ずしもBind変数を使用すべきでは無い。
→　復習　バッチ系の処理の時は、実行計画をやり直すから。

直積結合を行うことで結合したものを全てかいしてしまう。
データ量が多くなってくると課題が湧き出す恐れがある。

こうなっていないようにチェックしよう！
MERGE JOIN CARTESIAN　→　直積結合：結合条件が不足
MERGE JOIN　→　OK


結合順序をちゃんと指定しないと行けない。
OPTIMIZERが知らない。？？

外部表と内部表に分けられる。
まず外部表を読み込む

ヒント区を書くことで、OPTIMIZERへ結合順序を支持出来る。

外のループが少ない方が良い？？？
結果行数が少ない方から結合

表の結合数が増えるとまずい　→　2,000通りまでしか結合順っじょの解析をおこなわない。
結合数は極力６表まで→６！７２０通り。
結合数が６表いないでないとPFが以上問題が発生する。






SELECT * FROM v$nls_parameters;　//設定値一覧が参照出来る？















